const wss = require('socket.io')
const wss = require('ws')

socket.io는 ws를 더 깔끔하게 사용할 수 있게해준다.
우리는 ws로 배워보고 이후 모듈을 사용하도록 한다.

ws도 결국 http이다
요청헤더에 키를 설정하여, 원하는 대상에만 키를 전달하여 연결되는 방식
그리고 그 키값을 잘 보관해두어야 한다. 보통 변수저장해둔다
위키백과 읽어보는거 추천

# 웹소켓 handshake
웹소켓은 우선 서버가 실행되어야 한다.
웹소켓 서버가 닫혀있을때 요청이 되면 에러가 생긴다.

웹소켓을 연 대상을 서버로 정의한다.
웹소켓 포트를 열어 요청을 클라이언트로부터 받을 때 중요한 점은
3000번 열었다고 http프로토콜로 요청할 수 있는 것은 아니다
다시 말하자면 url에 http://localhost:3000을 입력한다하여 연결되는 것이 아니라,
웹소켓 프로토콜은 ws이기 때문에 ws://http://localhost:3000로 해야한다.
서버는 요청을 받으면 http에 대한 헤더정보를 받을 수 있다.
예를들어, 로그인 한 사람만 채팅하게끔 구현하자면 클라이언트의 최초접속 시 쿠키나 토큰여부를 확인하면 되는 등 헤더정보를 활용할 수 있다.

웹서버는 요청을 받으면 무조건적으로 응답을 한 번 준다.
연결인증에 대한 응답인 것이다.

웹소켓과 http(express)는 포트를 같이 쓸 수 있다.
두가지의 성격이 비슷하여 제한되지 않았다고 이해하면 된다.

# handshake 부분을 코드로 익혀본다.
app.liten로 return값을 반환한다 이를 응용해 express서버와 ws서버를 동시에 열수있다.
클라이언트 요청을 분류하여 각 서버로 전달한다.
즉,
클라이언트가 http로 요청하면 express 서버로 가고,
클라이언트가 ws로 요청하면 웹소켓 서버로 간다.

# 클라이언트 설정
js에는 웹소켓이라는 내장객체가 있어 그것을 사용한다.
연결을 확인하기 위해서는 브라우저의 네트워크 탭에서 새로고침 하면 101상태가 조회된다

# ws이벤트
  wss.on('connection', (ws, req) => {
    console.log('hello socket')
  })
  위 코드는 실제로 connection이 되는게 아니라 요청 후 응답시 실행되는 메세지이다.
  그저 이벤트 실행시 출력되는 것이다.
  socket.js의 webSocket과 index의 webSocket는 다르다
  index.html의 console.log(req.headers)를 찍으면 익숙한 http헤더를 확인할 수 있다.
  wss를 찍어보면 html과 socket에 대한 연결정보를 확인할 수 있다.
  배열로 관리하며 추후 채팅방 구성읻 ㅚㄴ다.
  ws의 send메소드는 서로간 정보를 교환하기 때문에 연결된 사람에게만 정보를 줄 수 있도록 하는 메소드이다.
  데이터를 던진 내용은 새로고침 후 네트워크 메세지의 body영역에서 확인할수있다.
  클라이언트에서 보낸 메세지를 받는 방법은 간단하다
  webSocket.onmessage()를 콜백으로 구현하면 된다.
  함수가 웹소켓 메세지를 호출시키는 것을 이용해 메세지를 작성해 주고받는 것이다.
  스트링으로 주고받기 때문에 보통 객체화를 시킨다 like리듀서...
  그러나 오브젝트로 만들어서 보낼 수 없기 대문에 toString으로 해야하낟.
  ex)
      const obj1 = {type : 'message', payload : 'heidi님 환영합니다.'}
      ws.send(JSON.stringify(obj1))


  결국 send한번 실행될때마다 onmessage가 실행된다. 2번 보내면 2번 실행되는 것
  이를 채팅형식으로 구현하기 위해 json형태로 만들어주고 data의 타입을 통해 조건문을 걸어 분류하여 자리를 넣어주면 된다.
  


  이 외에 자주 사용하는 이벤트는 close이다. 클라이언트에서 브라우저를 껐을 때 발동되는 이벤트이다.close 이벤트를 통해 사용자가 방을 나갔을때 로그를 남길 수 있다.
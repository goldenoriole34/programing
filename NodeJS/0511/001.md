로그인만들기
## JWT 코드 구현

### JWT
  왜 써야하는가?
  - 쿠키에는 유저의 정보를 담는다
  - 이러한 경우 다른 사람들이 그 유저의 정보를 쉽게 접근하여 수정까지도 가능하다.
  - 실제로 변경 후 쿠키를 보내면 변경된 정보로 서버가 받아들이는 것을 확인할 수 있다.
  - 그래서 과거에는 세션을 사용했으나
  - 최근에는 클라우드 서비스가 생기면서 토큰을 통한 로그인을 다시 사용하기 시작했다.
  - 원래 백 서버에서 동시 접속자수 퍼포먼스를 다루는데, 혹 그 이상의 유저가 들어오는 경우 서버가 터졌다.
  - 이전에는 통해 더 큰 서버로 옮기는 경우가 있었다.
  - 단점
  - 클라우드를 사용하면 이동 없이 컴퓨터에 용량을 추가한다.
  - 최근에는 같은 종류의 서버를 여러개를 띄우게 되었다.
  - 이러는 경우 서버에 저장하는 세션사용이 불편해진다. 다른 서버로 접근되어 버리면 로그인이 풀려버리는 것이다.
  - 따라서 로그인의 주체를 브라우저에게 주기로 하면서 쿠키를 다시 사용한다.
  - 쿠키의 보안이슈를 해소할 수 있는 형태가 jwt(토큰)이다.


### 쿠키구조와 JWT 동작원리
  - 헤더 : 객체
  - 페이로드 : 객체
  - 시그니처 : 헤더와 페이로드를 더한 스트링 값 (검증용도)
  - 위 객체들을 sha256으로 암호화하여 합친다. (객체를 스트링으로 바꿔 해시를 거쳐 암호화 하는 것)
  - 복호화를 진행해 원래대로 객체를 반환할 수 있다. 복호화 한 내용이 원본과 같다면 변조되지 않은 데이터로 인식되어 서버에서 응답을 해준다.

### header : 거의 고정값임
### payload : 공유할 정보를 만들어 넣어주는 곳

jwt를 통한 암호화 알고리즘은 양방향이지만 인코딩 정도이다.

## 암호화
- Buffer.from('str') 통해 16진수로 변형
- 더 나아가 16진수 -> 64진수로 변형함 (값이 줄어듬) toString('base64') 사용
base64는 정해진 규격임

## 인코딩 / 디코딩 / 단방향암호화
  - 암호화 예시: const encodingHeader = Buffer.from( JSON.stringify(header)).toString('base64').replace('==','').replace('=','')

  - 복호화 예시 : const decodingHeader = Buffer.from( encodingHeader, 'base64').toString()

  

  - 단방향 암호화 : 크립토-js 활용하여 sha-256로 단방향 암호화를 진행함 
    abc -> adfadfadf
    암호화 한 것을 복화할 수 있는것


  tip 헤더와 페이로드는 양방향
  시그니처는 sha356으로 하기 때문에 단방향이지만 편의상 양방향이라고 호칭한다


  코드를 우리가 활용할 수 있게 만들어 준다.

  salt 암호화 더 어렵게 하고 값은 보통 env파일에 넣는다

  # 로그인 로직 이해하기
  1. 로그인 화면이 필요
  2. 백 서버에 내용을 전달
    (post body (userid, userpw))
  3. 백 서버에서
    (post body (userid, userpw))